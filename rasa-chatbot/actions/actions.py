from typing import Any, Text, Dict, List
from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
from rasa_sdk.events import SlotSet
import requests
from datetime import datetime, timedelta
import logging

API_BASE_URL = "http://localhost:3000/api"
logger = logging.getLogger(__name__)

class ActionGetShowtimes(Action):
    def name(self) -> Text:
        return "action_get_showtimes"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        movie_name = tracker.get_slot("movie_name")
        cinema_name = tracker.get_slot("cinema_name")
        date = tracker.get_slot("date")
        
        logger.info(f"Slots - movie: {movie_name}, cinema: {cinema_name}, date: {date}")
        
        # Parse date
        if date:
            parsed_date = self.parse_date(date)
        else:
            parsed_date = datetime.now().strftime("%Y-%m-%d")
        
        try:
            # Scenario 1: C√≥ t√™n phim
            if movie_name:
                return self.get_showtimes_by_movie(
                    dispatcher, movie_name, cinema_name, parsed_date
                )
            
            # Scenario 2: Ch·ªâ c√≥ t√™n r·∫°p (kh√¥ng c√≥ phim c·ª• th·ªÉ)
            elif cinema_name:
                return self.get_showtimes_by_cinema(
                    dispatcher, cinema_name, parsed_date
                )
            
            # Scenario 3: Kh√¥ng c√≥ th√¥ng tin c·ª• th·ªÉ
            else:
                dispatcher.utter_message(
                    text="B·∫°n mu·ªën xem l·ªãch chi·∫øu c·ªßa phim n√†o? Ho·∫∑c b·∫°n mu·ªën xem l·ªãch chi·∫øu t·∫°i r·∫°p n√†o?"
                )
                return []
                
        except Exception as e:
            logger.error(f"Error in get_showtimes: {str(e)}", exc_info=True)
            dispatcher.utter_message(
                text="Xin l·ªói, c√≥ l·ªói x·∫£y ra khi l·∫•y th√¥ng tin l·ªãch chi·∫øu."
            )
        
        return []
    
    def get_showtimes_by_movie(self, dispatcher, movie_name, cinema_name, date):
        """L·∫•y l·ªãch chi·∫øu theo phim s·ª≠ d·ª•ng endpoint /showtimes/movies/:movie_id"""
        try:
            # B∆∞·ªõc 1: T√¨m movie_id t·ª´ t√™n phim
            movie_id, movie_info = self.find_movie_id(movie_name)
            
            if not movie_id:
                dispatcher.utter_message(
                    text=f"‚ùå Kh√¥ng t√¨m th·∫•y phim '{movie_name}' trong h·ªá th·ªëng.\n"
                         "Vui l√≤ng ki·ªÉm tra l·∫°i t√™n phim."
                )
                return []
            
            # B∆∞·ªõc 2: L·∫•y l·ªãch chi·∫øu c·ªßa phim t·ª´ API
            response = requests.get(
                f"{API_BASE_URL}/showtimes/movies/{movie_id}",
                timeout=5
            )
            
            logger.info(f"API Response status: {response.status_code}")
            
            if response.status_code != 200:
                dispatcher.utter_message(
                    text=f"Kh√¥ng th·ªÉ l·∫•y th√¥ng tin l·ªãch chi·∫øu cho phim '{movie_name}'."
                )
                return []
            
            data = response.json()
            logger.info(f"Response data keys: {data.keys() if isinstance(data, dict) else 'not dict'}")
            
            if not data.get('success'):
                dispatcher.utter_message(text="Kh√¥ng c√≥ d·ªØ li·ªáu l·ªãch chi·∫øu.")
                return []
            
            movie_data = data.get('movie', {})
            showtimes = data.get('dateTime', [])
            
            if not showtimes:
                dispatcher.utter_message(
                    text=f"Hi·ªán t·∫°i ch∆∞a c√≥ l·ªãch chi·∫øu cho phim '{movie_name}'."
                )
                return []
            
            # B∆∞·ªõc 3: L·ªçc theo r·∫°p n·∫øu c√≥
            if cinema_name:
                cinema_name_lower = cinema_name.lower()
                showtimes = [
                    st for st in showtimes
                    if cinema_name_lower in str(st.get('cinema_name', '')).lower()
                ]
                
                if not showtimes:
                    dispatcher.utter_message(
                        text=f"Phim '{movie_name}' kh√¥ng chi·∫øu t·∫°i r·∫°p '{cinema_name}'."
                    )
                    return []
            
            # B∆∞·ªõc 4: L·ªçc theo ng√†y
            filtered_by_date = []
            for st in showtimes:
                start_time = st.get('start_time', '')
                if start_time:
                    # Parse ISO datetime: "2025-10-10T05:44:00.000Z"
                    try:
                        st_date = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
                        st_date_str = st_date.strftime('%Y-%m-%d')
                        
                        if st_date_str == date:
                            filtered_by_date.append({**st, 'parsed_date': st_date})
                    except Exception as e:
                        logger.warning(f"Cannot parse date: {start_time}")
            
            # N·∫øu kh√¥ng c√≥ su·∫•t chi·∫øu trong ng√†y ƒë∆∞·ª£c ch·ªçn, hi·ªÉn th·ªã t·∫•t c·∫£
            if not filtered_by_date:
                logger.info(f"No showtimes on {date}, showing all available dates")
                for st in showtimes:
                    start_time = st.get('start_time', '')
                    if start_time:
                        try:
                            st_date = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
                            filtered_by_date.append({**st, 'parsed_date': st_date})
                        except:
                            pass
            
            if not filtered_by_date:
                dispatcher.utter_message(
                    text=f"Kh√¥ng t√¨m th·∫•y l·ªãch chi·∫øu ph√π h·ª£p."
                )
                return []
            
            # B∆∞·ªõc 5: Hi·ªÉn th·ªã th√¥ng tin
            self.display_movie_showtimes(
                dispatcher, 
                movie_data, 
                filtered_by_date, 
                cinema_name,
                date
            )
            
            return []
            
        except Exception as e:
            logger.error(f"Error in get_showtimes_by_movie: {str(e)}", exc_info=True)
            raise
    
    def get_showtimes_by_cinema(self, dispatcher, cinema_name, date):
        """L·∫•y l·ªãch chi·∫øu theo r·∫°p s·ª≠ d·ª•ng endpoint /showtimes/datve/:cinema_id/:date"""
        try:
            # B∆∞·ªõc 1: T√¨m cinema_id
            cinema_id = self.find_cinema_id(cinema_name)
            
            if not cinema_id:
                dispatcher.utter_message(
                    text=f"‚ùå Kh√¥ng t√¨m th·∫•y r·∫°p '{cinema_name}' trong h·ªá th·ªëng."
                )
                return []
            
            # B∆∞·ªõc 2: L·∫•y l·ªãch chi·∫øu
            response = requests.get(
                f"{API_BASE_URL}/showtimes/datve/{cinema_id}/{date}",
                timeout=5
            )
            
            if response.status_code != 200:
                dispatcher.utter_message(
                    text=f"Kh√¥ng th·ªÉ l·∫•y th√¥ng tin l·ªãch chi·∫øu cho r·∫°p '{cinema_name}'."
                )
                return []
            
            showtimes = response.json()
            
            # Parse response (c√≥ th·ªÉ l√† list ho·∫∑c dict)
            if isinstance(showtimes, dict):
                showtimes = showtimes.get('data', []) or showtimes.get('showtimes', [])
            
            if not showtimes:
                dispatcher.utter_message(
                    text=f"R·∫°p '{cinema_name}' ch∆∞a c√≥ l·ªãch chi·∫øu v√†o ng√†y {date}."
                )
                return []
            
            # B∆∞·ªõc 3: Hi·ªÉn th·ªã
            self.display_cinema_showtimes(dispatcher, cinema_name, showtimes, date)
            
            return []
            
        except Exception as e:
            logger.error(f"Error in get_showtimes_by_cinema: {str(e)}", exc_info=True)
            raise
    
    def display_movie_showtimes(self, dispatcher, movie_data, showtimes, cinema_filter, date):
        """Hi·ªÉn th·ªã l·ªãch chi·∫øu c·ªßa m·ªôt phim"""
        title = movie_data.get('title', 'N/A')
        runtime = movie_data.get('runtime', 'N/A')
        genres = movie_data.get('genres', [])
        vote_avg = movie_data.get('vote_average', 'N/A')
        
        message = f"üé¨ **{title}**\n"
        message += f"‚è±Ô∏è Th·ªùi l∆∞·ª£ng: {runtime} ph√∫t\n"
        if genres:
            message += f"üé≠ Th·ªÉ lo·∫°i: {', '.join(genres)}\n"
        if vote_avg != 'N/A':
            message += f"‚≠ê ƒê√°nh gi√°: {vote_avg}/10\n"
        message += "\nüìÖ **L·ªäCH CHI·∫æU:**\n\n"
        
        # Nh√≥m theo r·∫°p
        grouped_by_cinema = {}
        for st in showtimes:
            cinema = st.get('cinema_name', 'R·∫°p kh√¥ng x√°c ƒë·ªãnh')
            if cinema not in grouped_by_cinema:
                grouped_by_cinema[cinema] = []
            grouped_by_cinema[cinema].append(st)
        
        # S·∫Øp x·∫øp theo th·ªùi gian
        for cinema, times in grouped_by_cinema.items():
            times.sort(key=lambda x: x.get('parsed_date', datetime.now()))
        
        # Hi·ªÉn th·ªã t·ª´ng r·∫°p
        for cinema, times in grouped_by_cinema.items():
            message += f"üè¢ **{cinema}**\n"
            
            for st in times[:10]:  # Gi·ªõi h·∫°n 10 su·∫•t/r·∫°p
                showtime_id = st.get('id', 'N/A')
                room = st.get('room_name', 'N/A')
                parsed_date = st.get('parsed_date')
                
                if parsed_date:
                    time_str = parsed_date.strftime('%H:%M')
                    date_str = parsed_date.strftime('%d/%m')
                else:
                    time_str = 'N/A'
                    date_str = 'N/A'
                
                message += f"   ‚Ä¢ {date_str} - {time_str} | Ph√≤ng {room} | ID: {showtime_id}\n"
            
            message += "\n"
        
        message += "üí° **ƒê·ªÉ ƒë·∫∑t v√©:**\n"
        message += "Vui l√≤ng nh·ªõ **ID su·∫•t chi·∫øu** (v√≠ d·ª•: ID: 5)\n"
        message += "Sau ƒë√≥ b·∫°n c√≥ th·ªÉ xem gh·∫ø tr·ªëng ho·∫∑c ƒë·∫∑t v√© ngay!"
        
        dispatcher.utter_message(text=message)
    
    def display_cinema_showtimes(self, dispatcher, cinema_name, showtimes, date):
        """Hi·ªÉn th·ªã l·ªãch chi·∫øu c·ªßa m·ªôt r·∫°p"""
        message = f"üè¢ **L·ªãch chi·∫øu t·∫°i {cinema_name}**\n"
        message += f"üìÖ Ng√†y {date}\n\n"
        
        # Nh√≥m theo phim
        grouped_by_movie = {}
        for st in showtimes:
            movie = st.get('movie_title', '') or st.get('title', 'Phim kh√¥ng x√°c ƒë·ªãnh')
            if movie not in grouped_by_movie:
                grouped_by_movie[movie] = []
            grouped_by_movie[movie].append(st)
        
        for movie, times in grouped_by_movie.items():
            message += f"üé¨ **{movie}**\n"
            
            for st in times[:8]:  # Gi·ªõi h·∫°n 8 su·∫•t/phim
                showtime_id = st.get('id', 'N/A')
                show_time = st.get('show_time', '') or st.get('time', 'N/A')
                room = st.get('room_name', 'N/A')
                price = st.get('ticket_price', '')
                
                message += f"   ‚Ä¢ {show_time} | Ph√≤ng {room} | ID: {showtime_id}"
                if price:
                    message += f" | {price} VND"
                message += "\n"
            
            message += "\n"
        
        message += "üí° ƒê·ªÉ ƒë·∫∑t v√©, h√£y nh·ªõ ID su·∫•t chi·∫øu b·∫°n mu·ªën xem!"
        
        dispatcher.utter_message(text=message)
    
    def find_movie_id(self, movie_name):
        """T√¨m movie_id t·ª´ t√™n phim"""
        try:
            response = requests.get(f"{API_BASE_URL}/movies", timeout=5)
            
            if response.status_code != 200:
                return None, None
            
            movies_data = response.json()
            
            # Parse response
            if isinstance(movies_data, dict):
                movies = movies_data.get('data', []) or movies_data.get('movies', [])
            elif isinstance(movies_data, list):
                movies = movies_data
            else:
                return None, None
            
            # T√¨m ki·∫øm
            movie_name_lower = movie_name.lower()
            
            # T√¨m exact match tr∆∞·ªõc
            for movie in movies:
                if not isinstance(movie, dict):
                    continue
                
                title = str(movie.get('title', '') or movie.get('movie_name', '')).lower()
                
                if title == movie_name_lower:
                    movie_id = movie.get('movie_id') or movie.get('id')
                    return movie_id, movie
            
            # T√¨m partial match
            for movie in movies:
                if not isinstance(movie, dict):
                    continue
                
                title = str(movie.get('title', '') or movie.get('movie_name', '')).lower()
                
                if movie_name_lower in title or title in movie_name_lower:
                    movie_id = movie.get('movie_id') or movie.get('id')
                    return movie_id, movie
            
            return None, None
            
        except Exception as e:
            logger.error(f"Error finding movie: {str(e)}")
            return None, None
    
    def find_cinema_id(self, cinema_name):
        """T√¨m cinema_id t·ª´ t√™n r·∫°p"""
        try:
            response = requests.get(f"{API_BASE_URL}/cinemas", timeout=5)
            
            if response.status_code != 200:
                return None
            
            cinemas_data = response.json()
            
            # Parse response
            if isinstance(cinemas_data, dict):
                cinemas = cinemas_data.get('cinemas', []) or cinemas_data.get('data', [])
            elif isinstance(cinemas_data, list):
                cinemas = cinemas_data
            else:
                return None
            
            # T√¨m ki·∫øm
            cinema_name_lower = cinema_name.lower()
            
            for cinema in cinemas:
                if not isinstance(cinema, dict):
                    continue
                
                name = str(cinema.get('cinema_name', '') or cinema.get('name', '')).lower()
                
                if cinema_name_lower in name or name in cinema_name_lower:
                    return cinema.get('id') or cinema.get('cinema_id')
            
            return None
            
        except Exception as e:
            logger.error(f"Error finding cinema: {str(e)}")
            return None
    
    def parse_date(self, date_str):
        """Parse ng√†y th√°ng"""
        if not date_str or not isinstance(date_str, str):
            return datetime.now().strftime("%Y-%m-%d")
        
        today = datetime.now()
        date_str = str(date_str).strip().lower()
        
        if date_str in ["h√¥m nay", "hom nay", "today"]:
            return today.strftime("%Y-%m-%d")
        elif date_str in ["ng√†y mai", "ngay mai", "tomorrow"]:
            return (today + timedelta(days=1)).strftime("%Y-%m-%d")
        
        date_formats = ["%Y-%m-%d", "%d-%m-%Y", "%d/%m/%Y"]
        for fmt in date_formats:
            try:
                parsed = datetime.strptime(date_str, fmt)
                return parsed.strftime("%Y-%m-%d")
            except ValueError:
                continue
        
        return today.strftime("%Y-%m-%d")


class ActionGetAvailableSeats(Action):
    def name(self) -> Text:
        return "action_get_available_seats"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        showtime_id = tracker.get_slot("showtime_id")
        
        if not showtime_id:
            dispatcher.utter_message(
                text="‚ùì B·∫°n ch∆∞a cung c·∫•p m√£ su·∫•t chi·∫øu.\n\n"
                     "üìå Vui l√≤ng xem l·ªãch chi·∫øu tr∆∞·ªõc, sau ƒë√≥ cho t√¥i bi·∫øt **ID su·∫•t chi·∫øu** b·∫°n mu·ªën xem.\n"
                     "V√≠ d·ª•: 'Xem gh·∫ø tr·ªëng su·∫•t 5' ho·∫∑c 'Ki·ªÉm tra gh·∫ø ID 7'"
            )
            return []
        
        try:
            # S·ª≠ d·ª•ng API m·ªõi ƒë·ªÉ l·∫•y t·∫•t c·∫£ gh·∫ø v·ªõi tr·∫°ng th√°i
            response = requests.get(
                f"{API_BASE_URL}/showtimes/seats-status/{showtime_id}",
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                
                if not data.get('success'):
                    dispatcher.utter_message(
                        text="‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin gh·∫ø. Vui l√≤ng th·ª≠ l·∫°i."
                    )
                    return []
                
                summary = data.get('summary', {})
                room_info = data.get('roomInfo', {})
                available_seats = data.get('availableSeats', [])
                available_by_type = data.get('availableByType', {})
                occupied_seats = data.get('occupiedSeats', [])
                
                logger.info(f"Showtime {showtime_id}: {summary.get('available')} available, {summary.get('booked') + summary.get('reserved')} occupied")
                
                # T·∫°o th√¥ng b√°o
                message = f"üé´ **Su·∫•t chi·∫øu ID: {showtime_id}**\n"
                message += f"üè¢ Ph√≤ng: {room_info.get('room_name', 'N/A')}\n\n"
                
                message += f"üìä **T√¨nh tr·∫°ng gh·∫ø:**\n"
                message += f"‚Ä¢ T·ªïng s·ªë gh·∫ø: {summary.get('total', 0)}\n"
                message += f"‚Ä¢ ‚úÖ C√≤n tr·ªëng: **{summary.get('available', 0)} gh·∫ø**\n"
                message += f"‚Ä¢ ‚ùå ƒê√£ ƒë·∫∑t: {summary.get('booked', 0) + summary.get('reserved', 0)} gh·∫ø\n\n"
                
                if summary.get('available', 0) > 0:
                    message += "ü™ë **GH·∫æ C√íN TR·ªêNG:**\n\n"
                    
                    # Hi·ªÉn th·ªã gh·∫ø tr·ªëng theo lo·∫°i
                    for type_name, seats in available_by_type.items():
                        emoji = self.get_seat_type_emoji(type_name)
                        message += f"{emoji} **{type_name.capitalize()}** ({len(seats)} gh·∫ø):\n"
                        
                        # L·∫•y seat_number
                        seat_numbers = [s.get('seat_number', '') for s in seats]
                        seat_numbers = [s for s in seat_numbers if s]  # L·ªçc empty
                        
                        # Hi·ªÉn th·ªã t·ªëi ƒëa 30 gh·∫ø
                        if len(seat_numbers) > 30:
                            display = ", ".join(seat_numbers[:30])
                            message += f"   {display}\n"
                            message += f"   ... v√† {len(seat_numbers) - 30} gh·∫ø kh√°c\n"
                        else:
                            display = ", ".join(seat_numbers)
                            message += f"   {display}\n"
                        message += "\n"
                    
                    message += "üí° **ƒê·ªÉ ƒë·∫∑t v√©:**\n"
                    message += f"N√≥i: 'ƒê·∫∑t v√© su·∫•t {showtime_id}, gh·∫ø A1 A2'\n"
                    message += "(Thay A1, A2 b·∫±ng gh·∫ø b·∫°n mu·ªën t·ª´ danh s√°ch tr√™n)"
                    
                else:
                    message += "üò¢ **R·∫•t ti·∫øc, su·∫•t chi·∫øu n√†y ƒë√£ H·∫æT GH·∫æ!**\n\n"
                    message += "Vui l√≤ng ch·ªçn su·∫•t chi·∫øu kh√°c."
                
                dispatcher.utter_message(text=message)
                
            elif response.status_code == 404:
                dispatcher.utter_message(
                    text=f"‚ùå Kh√¥ng t√¨m th·∫•y su·∫•t chi·∫øu ID {showtime_id}.\n"
                         "Vui l√≤ng ki·ªÉm tra l·∫°i ID su·∫•t chi·∫øu."
                )
            elif response.status_code == 400:
                dispatcher.utter_message(
                    text=f"‚ùå M√£ su·∫•t chi·∫øu '{showtime_id}' kh√¥ng h·ª£p l·ªá."
                )
            else:
                dispatcher.utter_message(
                    text=f"‚ùå L·ªói khi l·∫•y th√¥ng tin gh·∫ø (HTTP {response.status_code})."
                )
                
        except requests.exceptions.Timeout:
            dispatcher.utter_message(text="‚è±Ô∏è Timeout khi k·∫øt n·ªëi API. Vui l√≤ng th·ª≠ l·∫°i.")
        except requests.exceptions.RequestException as e:
            logger.error(f"Request error in get seats: {str(e)}")
            dispatcher.utter_message(text="‚ùå L·ªói k·∫øt n·ªëi API. Vui l√≤ng ki·ªÉm tra backend server.")
        except Exception as e:
            logger.error(f"Error in get seats: {str(e)}", exc_info=True)
            dispatcher.utter_message(text="‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y th√¥ng tin gh·∫ø.")
        
        return []
    
    def get_seat_type_emoji(self, type_name):
        """L·∫•y emoji cho lo·∫°i gh·∫ø"""
        type_map = {
            'standard': 'ü™ë',
            'normal': 'ü™ë',
            'vip': '‚≠ê',
            'couple': 'üíë',
            'sweetbox': 'üíë'
        }
        return type_map.get(type_name.lower(), 'ü™ë')


class ActionCreateBooking(Action):
    def name(self) -> Text:
        return "action_create_booking"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        showtime_id = tracker.get_slot("showtime_id")
        seat_numbers = tracker.get_slot("seat_numbers")
        user_id = tracker.get_slot("user_id") or "guest_user"
        
        # L·∫•y t·ª´ latest message n·∫øu slot tr·ªëng
        if not showtime_id or not seat_numbers:
            latest_message = tracker.latest_message.get('text', '')
            logger.info(f"Latest message: {latest_message}")
            
            # Parse showtime_id t·ª´ message
            if not showtime_id:
                import re
                showtime_match = re.search(r'su·∫•t\s+(\d+)', latest_message, re.IGNORECASE)
                if showtime_match:
                    showtime_id = showtime_match.group(1)
                    logger.info(f"Extracted showtime_id: {showtime_id}")
            
            # Parse seat_numbers t·ª´ message
            if not seat_numbers:
                seat_numbers = self.extract_seat_numbers(latest_message)
                logger.info(f"Extracted seats: {seat_numbers}")
        
        if not showtime_id:
            dispatcher.utter_message(
                text="‚ùå Thi·∫øu **m√£ su·∫•t chi·∫øu**.\n"
                     "Vui l√≤ng n√≥i l·∫°i v·ªõi format: 'ƒê·∫∑t v√© su·∫•t [ID], gh·∫ø [A1 A2]'"
            )
            return []
        
        if not seat_numbers or (isinstance(seat_numbers, list) and len(seat_numbers) == 0):
            dispatcher.utter_message(
                text="‚ùå B·∫°n ch∆∞a ch·ªçn **gh·∫ø ng·ªìi**.\n"
                     "Vui l√≤ng n√≥i l·∫°i: 'ƒê·∫∑t v√© su·∫•t " + str(showtime_id) + ", gh·∫ø A1 A2'"
            )
            return []
        
        # ƒê·∫£m b·∫£o seat_numbers l√† list
        if isinstance(seat_numbers, str):
            seat_numbers = [s.strip() for s in seat_numbers.replace(',', ' ').split()]
        
        try:
            # Chu·∫©n b·ªã d·ªØ li·ªáu booking
            booking_data = {
                "user_id": user_id,
                "showtime_id": int(showtime_id),
                "seats": seat_numbers,
                "services": []
            }
            
            logger.info(f"Creating booking: {booking_data}")
            
            response = requests.post(
                f"{API_BASE_URL}/bookings/create-booking",
                json=booking_data,
                timeout=10
            )
            
            logger.info(f"Booking response status: {response.status_code}")
            
            if response.status_code == 200:
                result = response.json()
                order_id = result.get('order_id') or result.get('id')
                
                if order_id:
                    seats_display = ', '.join(seat_numbers) if isinstance(seat_numbers, list) else seat_numbers
                    
                    message = "‚úÖ **ƒê·∫∂T V√â TH√ÄNH C√îNG!**\n\n"
                    message += f"üìã **M√£ ƒë∆°n h√†ng:** {order_id}\n"
                    message += f"üé¨ **Su·∫•t chi·∫øu:** ID {showtime_id}\n"
                    message += f"ü™ë **Gh·∫ø ƒë√£ ƒë·∫∑t:** {seats_display}\n\n"
                    message += "‚è∞ Vui l√≤ng **thanh to√°n trong 15 ph√∫t** ƒë·ªÉ gi·ªØ v√©!\n\n"
                    message += "üí≥ B·∫°n c√≥ th·ªÉ h·ªèi: 'Thanh to√°n nh∆∞ th·∫ø n√†o?' ƒë·ªÉ ƒë∆∞·ª£c h∆∞·ªõng d·∫´n."
                    
                    dispatcher.utter_message(text=message)
                    return [
                        SlotSet("order_id", order_id),
                        SlotSet("showtime_id", None),  # Reset ƒë·ªÉ chu·∫©n b·ªã ƒë·∫∑t v√© m·ªõi
                        SlotSet("seat_numbers", None)
                    ]
                else:
                    dispatcher.utter_message(
                        text="‚úÖ ƒê·∫∑t v√© th√†nh c√¥ng nh∆∞ng kh√¥ng nh·∫≠n ƒë∆∞·ª£c m√£ ƒë∆°n h√†ng."
                    )
            else:
                try:
                    error_data = response.json()
                    error_msg = error_data.get('message', '') or error_data.get('error', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')
                except:
                    error_msg = f"HTTP {response.status_code}"
                
                dispatcher.utter_message(
                    text=f"‚ùå **ƒê·∫∑t v√© th·∫•t b·∫°i!**\n\n"
                         f"L√Ω do: {error_msg}\n\n"
                         f"C√≥ th·ªÉ:\n"
                         f"‚Ä¢ Gh·∫ø ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t\n"
                         f"‚Ä¢ Su·∫•t chi·∫øu kh√¥ng c√≤n kh·∫£ d·ª•ng\n"
                         f"‚Ä¢ M√£ gh·∫ø kh√¥ng ƒë√∫ng"
                )
                
        except requests.exceptions.Timeout:
            dispatcher.utter_message(text="‚è±Ô∏è Timeout khi ƒë·∫∑t v√©. Vui l√≤ng th·ª≠ l·∫°i.")
        except requests.exceptions.RequestException as e:
            logger.error(f"Request error in booking: {str(e)}")
            dispatcher.utter_message(text="‚ùå L·ªói k·∫øt n·ªëi API khi ƒë·∫∑t v√©.")
        except Exception as e:
            logger.error(f"Error in booking: {str(e)}", exc_info=True)
            dispatcher.utter_message(
                text=f"‚ùå C√≥ l·ªói x·∫£y ra khi ƒë·∫∑t v√©: {str(e)}"
            )
        
        return []
    
    def extract_seat_numbers(self, text):
        """Extract seat numbers t·ª´ text"""
        import re
        
        # T√¨m pattern: gh·∫ø A1 A2, gh·∫ø A1, A2, etc
        # Pattern matches: A1, B2, C10, V1, I4, etc
        seat_pattern = r'\b([A-Z]\d+)\b'
        seats = re.findall(seat_pattern, text.upper())
        
        logger.info(f"Extracted seats from '{text}': {seats}")
        return seats if seats else []


class ActionRedirectToPayment(Action):
    def name(self) -> Text:
        return "action_redirect_to_payment"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        order_id = tracker.get_slot("order_id")
        
        if order_id:
            payment_url = f"http://localhost:5173/payment/{order_id}"
            
            message = "üí≥ **H∆Ø·ªöNG D·∫™N THANH TO√ÅN**\n\n"
            message += f"üîó Vui l√≤ng truy c·∫≠p link sau ƒë·ªÉ thanh to√°n:\n"
            message += f"{payment_url}\n\n"
            message += "üìå **C√°c ph∆∞∆°ng th·ª©c thanh to√°n:**\n"
            message += "‚Ä¢ Th·∫ª ATM/Visa/Mastercard\n"
            message += "‚Ä¢ V√≠ ƒëi·ªán t·ª≠ (Momo, ZaloPay, VNPay)\n"
            message += "‚Ä¢ Chuy·ªÉn kho·∫£n ng√¢n h√†ng\n\n"
            message += "‚è∞ Th·ªùi gian gi·ªØ v√©: **15 ph√∫t**"
            
            dispatcher.utter_message(text=message)
        else:
            dispatcher.utter_message(
                text="‚ùå Kh√¥ng t√¨m th·∫•y m√£ ƒë∆°n h√†ng.\n"
                     "B·∫°n c√≥ th·ªÉ ƒë·∫∑t v√© m·ªõi b·∫±ng c√°ch n√≥i: 'ƒê·∫∑t v√© phim [t√™n phim]'"
            )
        
        return []


class ActionGetCinemaInfo(Action):
    def name(self) -> Text:
        return "action_get_cinema_info"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        cinema_name = tracker.get_slot("cinema_name")
        
        try:
            response = requests.get(f"{API_BASE_URL}/cinemas", timeout=5)
            
            if response.status_code == 200:
                cinemas_data = response.json()
                
                if isinstance(cinemas_data, dict):
                    cinemas = cinemas_data.get('cinemas', []) or cinemas_data.get('data', [])
                elif isinstance(cinemas_data, list):
                    cinemas = cinemas_data
                else:
                    dispatcher.utter_message(text="ƒê·ªãnh d·∫°ng d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.")
                    return []
                
                cinemas = [c for c in cinemas if isinstance(c, dict)]
                
                if cinema_name:
                    cinema_name_lower = cinema_name.lower()
                    cinemas = [
                        c for c in cinemas
                        if cinema_name_lower in str(c.get('cinema_name', '') or c.get('name', '')).lower()
                    ]
                
                if cinemas:
                    message = "üé¨ **TH√îNG TIN R·∫†P CHI·∫æU PHIM**\n\n"
                    
                    for cinema in cinemas[:5]:
                        name = cinema.get('cinema_name', '') or cinema.get('name', 'N/A')
                        address = cinema.get('address', 'N/A')
                        phone = cinema.get('cinema_phone', '') or cinema.get('phone', 'N/A')
                        cinema_id = cinema.get('id') or cinema.get('cinema_id', 'N/A')
                        
                        message += f"üè¢ **{name}**\n"
                        message += f"üìç ƒê·ªãa ch·ªâ: {address}\n"
                        message += f"‚òéÔ∏è Hotline: {phone}\n"
                        message += f"üÜî ID: {cinema_id}\n\n"
                    
                    message += "üí° B·∫°n c√≥ th·ªÉ h·ªèi: 'L·ªãch chi·∫øu t·∫°i [t√™n r·∫°p]' ƒë·ªÉ xem l·ªãch chi·∫øu!"
                    
                    dispatcher.utter_message(text=message)
                else:
                    dispatcher.utter_message(
                        text="‚ùå Kh√¥ng t√¨m th·∫•y r·∫°p ph√π h·ª£p.\n"
                             "Vui l√≤ng th·ª≠ l·∫°i v·ªõi t√™n r·∫°p kh√°c."
                    )
            else:
                dispatcher.utter_message(text="Kh√¥ng th·ªÉ l·∫•y th√¥ng tin r·∫°p.")
                
        except Exception as e:
            logger.error(f"Error in cinema info: {str(e)}")
            dispatcher.utter_message(text="C√≥ l·ªói x·∫£y ra.")
        
        return []


class ActionGetMovieInfo(Action):
    def name(self) -> Text:
        return "action_get_movie_info"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        movie_name = tracker.get_slot("movie_name")
        
        try:
            response = requests.get(f"{API_BASE_URL}/movies", timeout=5)
            
            if response.status_code == 200:
                movies_data = response.json()
                
                if isinstance(movies_data, dict):
                    movies = movies_data.get('data', []) or movies_data.get('movies', [])
                elif isinstance(movies_data, list):
                    movies = movies_data
                else:
                    dispatcher.utter_message(text="ƒê·ªãnh d·∫°ng d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.")
                    return []
                
                movies = [m for m in movies if isinstance(m, dict)]
                
                if movie_name:
                    movie_name_lower = movie_name.lower()
                    movies = [
                        m for m in movies
                        if movie_name_lower in str(m.get('title', '') or m.get('movie_name', '')).lower()
                    ]
                
                if movies:
                    message = "üé¨ **TH√îNG TIN PHIM**\n\n"
                    
                    for movie in movies[:3]:
                        title = movie.get('title', '') or movie.get('movie_name', 'N/A')
                        release = movie.get('release_date', 'N/A')
                        duration = movie.get('duration', '') or movie.get('runtime', 'N/A')
                        genre = movie.get('genre', '') or movie.get('genres', [])
                        if isinstance(genre, list):
                            genre = ', '.join(genre)
                        desc = str(movie.get('description', '') or movie.get('overview', ''))
                        vote_avg = movie.get('vote_average', '')
                        movie_id = movie.get('movie_id', '') or movie.get('id', '')
                        
                        message += f"üé¨ **{title}**\n"
                        
                        if release != 'N/A':
                            try:
                                release_date = datetime.fromisoformat(release.replace('Z', '+00:00'))
                                release = release_date.strftime('%d/%m/%Y')
                            except:
                                pass
                            message += f"üìÖ Kh·ªüi chi·∫øu: {release}\n"
                        
                        if duration != 'N/A':
                            message += f"‚è±Ô∏è Th·ªùi l∆∞·ª£ng: {duration} ph√∫t\n"
                        
                        if genre:
                            message += f"üé≠ Th·ªÉ lo·∫°i: {genre}\n"
                        
                        if vote_avg:
                            message += f"‚≠ê ƒê√°nh gi√°: {vote_avg}/10\n"
                        
                        if movie_id:
                            message += f"üÜî ID: {movie_id}\n"
                        
                        if desc and len(desc) > 10:
                            desc_short = desc[:200] + "..." if len(desc) > 200 else desc
                            message += f"üìù M√¥ t·∫£: {desc_short}\n"
                        
                        message += "\n"
                    
                    message += "üí° B·∫°n c√≥ th·ªÉ h·ªèi: 'L·ªãch chi·∫øu phim [t√™n phim]' ƒë·ªÉ xem su·∫•t chi·∫øu!"
                    
                    dispatcher.utter_message(text=message)
                else:
                    dispatcher.utter_message(
                        text="‚ùå Kh√¥ng t√¨m th·∫•y phim ph√π h·ª£p.\n"
                             "Vui l√≤ng th·ª≠ l·∫°i v·ªõi t√™n phim kh√°c."
                    )
            else:
                dispatcher.utter_message(text="Kh√¥ng th·ªÉ l·∫•y th√¥ng tin phim.")
                
        except Exception as e:
            logger.error(f"Error in movie info: {str(e)}")
            dispatcher.utter_message(text="C√≥ l·ªói x·∫£y ra.")
        
        return []