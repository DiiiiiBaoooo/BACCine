from typing import Any, Text, Dict, List
from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
from rasa_sdk.events import SlotSet
import requests
from datetime import datetime, timedelta
import logging

API_BASE_URL = "http://localhost:3000/api"
logger = logging.getLogger(__name__)

class ActionGetShowtimes(Action):
    def name(self) -> Text:
        return "action_get_showtimes"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        movie_name = tracker.get_slot("movie_name")
        cinema_name = tracker.get_slot("cinema_name")
        date = tracker.get_slot("date")
        
        logger.info(f"Slots - movie: {movie_name}, cinema: {cinema_name}, date: {date}")
        
        if date:
            parsed_date = self.parse_date(date)
        else:
            parsed_date = datetime.now().strftime("%Y-%m-%d")
        
        try:
            if movie_name:
                return self.get_showtimes_by_movie(
                    dispatcher, movie_name, cinema_name, parsed_date
                )
            elif cinema_name:
                return self.get_showtimes_by_cinema(
                    dispatcher, cinema_name, parsed_date
                )
            else:
                dispatcher.utter_message(
                    text="B·∫°n mu·ªën xem l·ªãch chi·∫øu c·ªßa phim n√†o? Ho·∫∑c b·∫°n mu·ªën xem l·ªãch chi·∫øu t·∫°i r·∫°p n√†o?"
                )
                return []
                
        except Exception as e:
            logger.error(f"Error in get_showtimes: {str(e)}", exc_info=True)
            dispatcher.utter_message(
                text="Xin l·ªói, c√≥ l·ªói x·∫£y ra khi l·∫•y th√¥ng tin l·ªãch chi·∫øu."
            )
        
        return []
    
    def get_showtimes_by_movie(self, dispatcher, movie_name, cinema_name, date):
        try:
            movie_id, movie_info = self.find_movie_id(movie_name)
            
            if not movie_id:
                dispatcher.utter_message(
                    text=f"‚ùå Kh√¥ng t√¨m th·∫•y phim '{movie_name}' trong h·ªá th·ªëng.\n"
                         "Vui l√≤ng ki·ªÉm tra l·∫°i t√™n phim."
                )
                return []
            
            response = requests.get(
                f"{API_BASE_URL}/showtimes/movies/{movie_id}",
                timeout=5
            )
            
            logger.info(f"API Response status: {response.status_code}")
            
            if response.status_code != 200:
                dispatcher.utter_message(
                    text=f"Kh√¥ng th·ªÉ l·∫•y th√¥ng tin l·ªãch chi·∫øu cho phim '{movie_name}'."
                )
                return []
            
            data = response.json()
            logger.info(f"Response data keys: {data.keys() if isinstance(data, dict) else 'not dict'}")
            
            if not data.get('success'):
                dispatcher.utter_message(text="Kh√¥ng c√≥ d·ªØ li·ªáu l·ªãch chi·∫øu.")
                return []
            
            movie_data = data.get('movie', {})
            showtimes = data.get('dateTime', [])
            
            if not showtimes:
                dispatcher.utter_message(
                    text=f"Hi·ªán t·∫°i ch∆∞a c√≥ l·ªãch chi·∫øu cho phim '{movie_name}'."
                )
                return []
            
            if cinema_name:
                cinema_name_lower = cinema_name.lower()
                showtimes = [
                    st for st in showtimes
                    if cinema_name_lower in str(st.get('cinema_name', '')).lower()
                ]
                
                if not showtimes:
                    dispatcher.utter_message(
                        text=f"Phim '{movie_name}' kh√¥ng chi·∫øu t·∫°i r·∫°p '{cinema_name}'."
                    )
                    return []
            
            filtered_by_date = []
            for st in showtimes:
                start_time = st.get('start_time', '')
                if start_time:
                    try:
                        st_date = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
                        st_date_str = st_date.strftime('%Y-%m-%d')
                        
                        if st_date_str == date:
                            filtered_by_date.append({**st, 'parsed_date': st_date})
                    except Exception as e:
                        logger.warning(f"Cannot parse date: {start_time}")
            
            if not filtered_by_date:
                logger.info(f"No showtimes on {date}, showing all available dates")
                for st in showtimes:
                    start_time = st.get('start_time', '')
                    if start_time:
                        try:
                            st_date = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
                            filtered_by_date.append({**st, 'parsed_date': st_date})
                        except:
                            pass
            
            if not filtered_by_date:
                dispatcher.utter_message(
                    text=f"Kh√¥ng t√¨m th·∫•y l·ªãch chi·∫øu ph√π h·ª£p."
                )
                return []
            
            self.display_movie_showtimes(
                dispatcher, 
                movie_data, 
                filtered_by_date, 
                cinema_name,
                date
            )
            
            return []
            
        except Exception as e:
            logger.error(f"Error in get_showtimes_by_movie: {str(e)}", exc_info=True)
            raise
    
    def get_showtimes_by_cinema(self, dispatcher, cinema_name, date):
        try:
            cinema_id = self.find_cinema_id(cinema_name)
            
            if not cinema_id:
                dispatcher.utter_message(
                    text=f"‚ùå Kh√¥ng t√¨m th·∫•y r·∫°p '{cinema_name}' trong h·ªá th·ªëng."
                )
                return []
            
            response = requests.get(
                f"{API_BASE_URL}/showtimes/datve/{cinema_id}/{date}",
                timeout=5
            )
            
            if response.status_code != 200:
                dispatcher.utter_message(
                    text=f"Kh√¥ng th·ªÉ l·∫•y th√¥ng tin l·ªãch chi·∫øu cho r·∫°p '{cinema_name}'."
                )
                return []
            
            showtimes = response.json()
            
            if isinstance(showtimes, dict):
                showtimes = showtimes.get('data', []) or showtimes.get('showtimes', [])
            
            if not showtimes:
                dispatcher.utter_message(
                    text=f"R·∫°p '{cinema_name}' ch∆∞a c√≥ l·ªãch chi·∫øu v√†o ng√†y {date}."
                )
                return []
            
            self.display_cinema_showtimes(dispatcher, cinema_name, showtimes, date)
            
            return []
            
        except Exception as e:
            logger.error(f"Error in get_showtimes_by_cinema: {str(e)}", exc_info=True)
            raise
    
    def display_movie_showtimes(self, dispatcher, movie_data, showtimes, cinema_filter, date):
        title = movie_data.get('title', 'N/A')
        runtime = movie_data.get('runtime', 'N/A')
        genres = movie_data.get('genres', [])
        vote_avg = movie_data.get('vote_average', 'N/A')
        
        message = f"üé¨ **{title}**\n"
        message += f"‚è±Ô∏è Th·ªùi l∆∞·ª£ng: {runtime} ph√∫t\n"
        if genres:
            message += f"üé≠ Th·ªÉ lo·∫°i: {', '.join(genres)}\n"
        if vote_avg != 'N/A':
            message += f"‚≠ê ƒê√°nh gi√°: {vote_avg}/10\n"
        message += "\nüìÖ **L·ªäCH CHI·∫æU:**\n\n"
        
        grouped_by_cinema = {}
        for st in showtimes:
            cinema = st.get('cinema_name', 'R·∫°p kh√¥ng x√°c ƒë·ªãnh')
            if cinema not in grouped_by_cinema:
                grouped_by_cinema[cinema] = []
            grouped_by_cinema[cinema].append(st)
        
        for cinema, times in grouped_by_cinema.items():
            times.sort(key=lambda x: x.get('parsed_date', datetime.now()))
        
        for cinema, times in grouped_by_cinema.items():
            message += f"üè¢ **{cinema}**\n"
            
            for st in times[:10]:
                showtime_id = st.get('id', 'N/A')
                room = st.get('room_name', 'N/A')
                parsed_date = st.get('parsed_date')
                
                if parsed_date:
                    time_str = parsed_date.strftime('%H:%M')
                    date_str = parsed_date.strftime('%d/%m')
                else:
                    time_str = 'N/A'
                    date_str = 'N/A'
                
                message += f"   ‚Ä¢ {date_str} - {time_str} | Ph√≤ng {room} | ID: {showtime_id}\n"
            
            message += "\n"
        
        message += "üí° **ƒê·ªÉ ƒë·∫∑t v√©:**\n"
        message += "Vui l√≤ng nh·ªõ **ID su·∫•t chi·∫øu** (v√≠ d·ª•: ID: 5)\n"
        message += "Sau ƒë√≥ b·∫°n c√≥ th·ªÉ xem gh·∫ø tr·ªëng ho·∫∑c ƒë·∫∑t v√© ngay!"
        
        dispatcher.utter_message(text=message)
    
    def display_cinema_showtimes(self, dispatcher, cinema_name, showtimes, date):
        message = f"üè¢ **L·ªãch chi·∫øu t·∫°i {cinema_name}**\n"
        message += f"üìÖ Ng√†y {date}\n\n"
        
        grouped_by_movie = {}
        for st in showtimes:
            movie = st.get('movie_title', '') or st.get('title', 'Phim kh√¥ng x√°c ƒë·ªãnh')
            if movie not in grouped_by_movie:
                grouped_by_movie[movie] = []
            grouped_by_movie[movie].append(st)
        
        for movie, times in grouped_by_movie.items():
            message += f"üé¨ **{movie}**\n"
            
            for st in times[:8]:
                showtime_id = st.get('id', 'N/A')
                show_time = st.get('show_time', '') or st.get('time', 'N/A')
                room = st.get('room_name', 'N/A')
                price = st.get('ticket_price', '')
                
                message += f"   ‚Ä¢ {show_time} | Ph√≤ng {room} | ID: {showtime_id}"
                if price:
                    message += f" | {price} VND"
                message += "\n"
            
            message += "\n"
        
        message += "üí° ƒê·ªÉ ƒë·∫∑t v√©, h√£y nh·ªõ ID su·∫•t chi·∫øu b·∫°n mu·ªën xem!"
        
        dispatcher.utter_message(text=message)
    
    def find_movie_id(self, movie_name):
        try:
            response = requests.get(f"{API_BASE_URL}/movies", timeout=5)
            
            if response.status_code != 200:
                return None, None
            
            movies_data = response.json()
            
            if isinstance(movies_data, dict):
                movies = movies_data.get('data', []) or movies_data.get('movies', [])
            elif isinstance(movies_data, list):
                movies = movies_data
            else:
                return None, None
            
            movie_name_lower = movie_name.lower()
            
            for movie in movies:
                if not isinstance(movie, dict):
                    continue
                
                title = str(movie.get('title', '') or movie.get('movie_name', '')).lower()
                
                if title == movie_name_lower:
                    movie_id = movie.get('movie_id') or movie.get('id')
                    return movie_id, movie
            
            for movie in movies:
                if not isinstance(movie, dict):
                    continue
                
                title = str(movie.get('title', '') or movie.get('movie_name', '')).lower()
                
                if movie_name_lower in title or title in movie_name_lower:
                    movie_id = movie.get('movie_id') or movie.get('id')
                    return movie_id, movie
            
            return None, None
            
        except Exception as e:
            logger.error(f"Error finding movie: {str(e)}")
            return None, None
    
    def find_cinema_id(self, cinema_name):
        try:
            response = requests.get(f"{API_BASE_URL}/cinemas", timeout=5)
            
            if response.status_code != 200:
                return None
            
            cinemas_data = response.json()
            
            if isinstance(cinemas_data, dict):
                cinemas = cinemas_data.get('cinemas', []) or cinemas_data.get('data', [])
            elif isinstance(cinemas_data, list):
                cinemas = cinemas_data
            else:
                return None
            
            cinema_name_lower = cinema_name.lower()
            
            for cinema in cinemas:
                if not isinstance(cinema, dict):
                    continue
                
                name = str(cinema.get('cinema_name', '') or cinema.get('name', '')).lower()
                
                if cinema_name_lower in name or name in cinema_name_lower:
                    return cinema.get('id') or cinema.get('cinema_id')
            
            return None
            
        except Exception as e:
            logger.error(f"Error finding cinema: {str(e)}")
            return None
    
    def parse_date(self, date_str):
        if not date_str or not isinstance(date_str, str):
            return datetime.now().strftime("%Y-%m-%d")
        
        today = datetime.now()
        date_str = str(date_str).strip().lower()
        
        if date_str in ["h√¥m nay", "hom nay", "today"]:
            return today.strftime("%Y-%m-%d")
        elif date_str in ["ng√†y mai", "ngay mai", "tomorrow"]:
            return (today + timedelta(days=1)).strftime("%Y-%m-%d")
        
        date_formats = ["%Y-%m-%d", "%d-%m-%Y", "%d/%m/%Y"]
        for fmt in date_formats:
            try:
                parsed = datetime.strptime(date_str, fmt)
                return parsed.strftime("%Y-%m-%d")
            except ValueError:
                continue
        
        return today.strftime("%Y-%m-%d")


class ActionGetAvailableSeats(Action):
    def name(self) -> Text:
        return "action_get_available_seats"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        showtime_id = tracker.get_slot("showtime_id")
        
        if not showtime_id:
            dispatcher.utter_message(
                text="‚ùì B·∫°n ch∆∞a cung c·∫•p m√£ su·∫•t chi·∫øu.\n\n"
                     "üìå Vui l√≤ng xem l·ªãch chi·∫øu tr∆∞·ªõc, sau ƒë√≥ cho t√¥i bi·∫øt **ID su·∫•t chi·∫øu** b·∫°n mu·ªën xem.\n"
                     "V√≠ d·ª•: 'Xem gh·∫ø tr·ªëng su·∫•t 5' ho·∫∑c 'Ki·ªÉm tra gh·∫ø ID 7'"
            )
            return []
        
        try:
            response = requests.get(
                f"{API_BASE_URL}/showtimes/seats-status/{showtime_id}",
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                
                if not data.get('success'):
                    dispatcher.utter_message(
                        text="‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin gh·∫ø. Vui l√≤ng th·ª≠ l·∫°i."
                    )
                    return []
                
                summary = data.get('summary', {})
                room_info = data.get('roomInfo', {})
                available_seats = data.get('availableSeats', [])
                available_by_type = data.get('availableByType', {})
                occupied_seats = data.get('occupiedSeats', [])
                
                logger.info(f"Showtime {showtime_id}: {summary.get('available')} available, {summary.get('booked') + summary.get('reserved')} occupied")
                
                message = f"üé´ **Su·∫•t chi·∫øu ID: {showtime_id}**\n"
                message += f"üè¢ Ph√≤ng: {room_info.get('room_name', 'N/A')}\n\n"
                
                message += f"üìä **T√¨nh tr·∫°ng gh·∫ø:**\n"
                message += f"‚Ä¢ T·ªïng s·ªë gh·∫ø: {summary.get('total', 0)}\n"
                message += f"‚Ä¢ ‚úÖ C√≤n tr·ªëng: **{summary.get('available', 0)} gh·∫ø**\n"
                message += f"‚Ä¢ ‚ùå ƒê√£ ƒë·∫∑t: {summary.get('booked', 0) + summary.get('reserved', 0)} gh·∫ø\n\n"
                
                if summary.get('available', 0) > 0:
                    message += "ü™ë **GH·∫æ C√íN TR·ªêNG:**\n\n"
                    
                    for type_name, seats in available_by_type.items():
                        emoji = self.get_seat_type_emoji(type_name)
                        message += f"{emoji} **{type_name.capitalize()}** ({len(seats)} gh·∫ø):\n"
                        
                        seat_numbers = [s.get('seat_number', '') for s in seats]
                        seat_numbers = [s for s in seat_numbers if s]
                        
                        if len(seat_numbers) > 30:
                            display = ", ".join(seat_numbers[:30])
                            message += f"   {display}\n"
                            message += f"   ... v√† {len(seat_numbers) - 30} gh·∫ø kh√°c\n"
                        else:
                            display = ", ".join(seat_numbers)
                            message += f"   {display}\n"
                        message += "\n"
                    
                    message += "üí° **ƒê·ªÉ ƒë·∫∑t v√©:**\n"
                    message += f"N√≥i: 'ƒê·∫∑t v√© su·∫•t {showtime_id}, gh·∫ø A1 A2'\n"
                    message += "(Thay A1, A2 b·∫±ng gh·∫ø b·∫°n mu·ªën t·ª´ danh s√°ch tr√™n)"
                    
                else:
                    message += "üò¢ **R·∫•t ti·∫øc, su·∫•t chi·∫øu n√†y ƒë√£ H·∫æT GH·∫æ!**\n\n"
                    message += "Vui l√≤ng ch·ªçn su·∫•t chi·∫øu kh√°c."
                
                dispatcher.utter_message(text=message)
                
            elif response.status_code == 404:
                dispatcher.utter_message(
                    text=f"‚ùå Kh√¥ng t√¨m th·∫•y su·∫•t chi·∫øu ID {showtime_id}.\n"
                         "Vui l√≤ng ki·ªÉm tra l·∫°i ID su·∫•t chi·∫øu."
                )
            elif response.status_code == 400:
                dispatcher.utter_message(
                    text=f"‚ùå M√£ su·∫•t chi·∫øu '{showtime_id}' kh√¥ng h·ª£p l·ªá."
                )
            else:
                dispatcher.utter_message(
                    text=f"‚ùå L·ªói khi l·∫•y th√¥ng tin gh·∫ø (HTTP {response.status_code})."
                )
                
        except requests.exceptions.Timeout:
            dispatcher.utter_message(text="‚è±Ô∏è Timeout khi k·∫øt n·ªëi API. Vui l√≤ng th·ª≠ l·∫°i.")
        except requests.exceptions.RequestException as e:
            logger.error(f"Request error in get seats: {str(e)}")
            dispatcher.utter_message(text="‚ùå L·ªói k·∫øt n·ªëi API. Vui l√≤ng ki·ªÉm tra backend server.")
        except Exception as e:
            logger.error(f"Error in get seats: {str(e)}", exc_info=True)
            dispatcher.utter_message(text="‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y th√¥ng tin gh·∫ø.")
        
        return []
    
    def get_seat_type_emoji(self, type_name):
        type_map = {
            'standard': 'ü™ë',
            'normal': 'ü™ë',
            'vip': '‚≠ê',
            'couple': 'üíë',
            'sweetbox': 'üíë'
        }
        return type_map.get(type_name.lower(), 'ü™ë')


class ActionCreateBooking(Action):
    def name(self) -> Text:
        return "action_create_booking"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        showtime_id = tracker.get_slot("showtime_id")
        seat_numbers = tracker.get_slot("seat_numbers")
        user_id = tracker.get_slot("user_id") or "guest_user"
        logger.info(f"Retrieved user_id: {user_id} (type: {type(user_id)})")
        # L·∫•y t·ª´ latest message n·∫øu slot tr·ªëng
        if not showtime_id or not seat_numbers:
            latest_message = tracker.latest_message.get('text', '')
            logger.info(f"Latest message: {latest_message}")
            
            if not showtime_id:
                import re
                showtime_match = re.search(r'su·∫•t\s+(\d+)', latest_message, re.IGNORECASE)
                if showtime_match:
                    showtime_id = showtime_match.group(1)
                    logger.info(f"Extracted showtime_id: {showtime_id}")
            
            if not seat_numbers:
                seat_numbers = self.extract_seat_numbers(latest_message)
                logger.info(f"Extracted seats: {seat_numbers}")
        
        if not showtime_id:
            dispatcher.utter_message(
                text="‚ùå Thi·∫øu **m√£ su·∫•t chi·∫øu**.\n"
                     "Vui l√≤ng n√≥i l·∫°i v·ªõi format: 'ƒê·∫∑t v√© su·∫•t [ID], gh·∫ø [A1 A2]'"
            )
            return []
        
        if not seat_numbers or (isinstance(seat_numbers, list) and len(seat_numbers) == 0):
            dispatcher.utter_message(
                text="‚ùå B·∫°n ch∆∞a ch·ªçn **gh·∫ø ng·ªìi**.\n"
                     "Vui l√≤ng n√≥i l·∫°i: 'ƒê·∫∑t v√© su·∫•t " + str(showtime_id) + ", gh·∫ø A1 A2'"
            )
            return []
        
        # ƒê·∫£m b·∫£o seat_numbers l√† list
        if isinstance(seat_numbers, str):
            seat_numbers = [s.strip() for s in seat_numbers.replace(',', ' ').split()]
        
        try:
            # ========================================
            # B∆Ø·ªöC 1: L·∫•y th√¥ng tin gh·∫ø tr∆∞·ªõc (ƒë·ªÉ validate showtime t·ªìn t·∫°i)
            # ========================================
            seat_response = requests.get(
                f"{API_BASE_URL}/showtimes/seats-status/{showtime_id}",
                timeout=5
            )
            
            if seat_response.status_code != 200:
                dispatcher.utter_message(
                    text=f"‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin gh·∫ø cho su·∫•t chi·∫øu ID {showtime_id}"
                )
                return []
            
            seat_data = seat_response.json()
            if not seat_data.get('success'):
                dispatcher.utter_message(text="‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin gh·∫ø")
                return []
            
            # L·∫•y danh s√°ch gh·∫ø available
            available_seats = seat_data.get('availableSeats', [])
            
            # Th·ª≠ l·∫•y cinema_id t·ª´ roomInfo ho·∫∑c c√°c field kh√°c
            room_info = seat_data.get('roomInfo', {})
            cinema_id = (
                seat_data.get('cinema_id') or 
                seat_data.get('cinemaId') or 
                seat_data.get('cinema_cluster_id') or
                room_info.get('cinema_id') or
                room_info.get('cinema_cluster_id')
            )
            
            logger.info(f"Seat data keys: {seat_data.keys()}")
            logger.info(f"Room info: {room_info}")
            logger.info(f"Extracted cinema_id: {cinema_id}")
            
            # N·∫øu kh√¥ng t√¨m th·∫•y cinema_id, th·ª≠ query t·ª´ showtimes/all
            if not cinema_id:
                logger.info("Cinema ID not found in seat data, trying /showtimes/all")
                
                showtime_response = requests.get(
                    f"{API_BASE_URL}/showtimes/all",
                    timeout=5
                )
                
                if showtime_response.status_code == 200:
                    all_showtimes = showtime_response.json()
                    
                    logger.info(f"All showtimes response type: {type(all_showtimes)}")
                    
                    # Parse response
                    showtimes_list = []
                    if isinstance(all_showtimes, list):
                        showtimes_list = all_showtimes
                    elif isinstance(all_showtimes, dict):
                        showtimes_list = (
                            all_showtimes.get('data', []) or 
                            all_showtimes.get('showtimes', []) or
                            all_showtimes.get('dateTime', [])
                        )
                    
                    logger.info(f"Showtimes list length: {len(showtimes_list)}")
                    
                    # T√¨m showtime v·ªõi showtime_id
                    showtime_info = next((st for st in showtimes_list if st.get('id') == int(showtime_id)), None)
                    
                    if showtime_info:
                        cinema_id = (
                            showtime_info.get('cinema_id') or 
                            showtime_info.get('cinemaId') or 
                            showtime_info.get('cinema_cluster_id')
                        )
                        logger.info(f"Found showtime info: {showtime_info.keys()}")
                        logger.info(f"Extracted cinema_id from showtime: {cinema_id}")
            
            # N·∫øu v·∫´n kh√¥ng c√≥ cinema_id, d√πng gi√° tr·ªã m·∫∑c ƒë·ªãnh t·ª´ context
            # ho·∫∑c y√™u c·∫ßu user cung c·∫•p
            if not cinema_id:
                # Th·ª≠ l·∫•y t·ª´ conversation context (cinema ƒë∆∞·ª£c ch·ªçn tr∆∞·ªõc ƒë√≥)
                cinema_name = tracker.get_slot("cinema_name")
                if cinema_name:
                    logger.info(f"Trying to find cinema_id from name: {cinema_name}")
                    cinema_id = self.find_cinema_id_from_name(cinema_name)
                    logger.info(f"Found cinema_id from name: {cinema_id}")
            
            if not cinema_id:
                dispatcher.utter_message(
                    text="‚ùå Kh√¥ng th·ªÉ x√°c ƒë·ªãnh r·∫°p chi·∫øu.\n\n"
                         "Vui l√≤ng th·ª≠ l·∫°i b·∫±ng c√°ch:\n"
                         "1. Xem l·ªãch chi·∫øu phim t·∫°i r·∫°p tr∆∞·ªõc\n"
                         "2. Sau ƒë√≥ ƒë·∫∑t v√© v·ªõi ID su·∫•t chi·∫øu\n\n"
                         "V√≠ d·ª•: 'L·ªãch chi·∫øu t·∫°i BAC Quang Trung' ‚Üí sau ƒë√≥ 'ƒê·∫∑t v√© su·∫•t 7, gh·∫ø A1 A2'"
                )
                return []
            
            logger.info(f"Final cinema_id: {cinema_id} for showtime {showtime_id}")
            
            # ========================================
            # B∆Ø·ªöC 2: L·∫•y th√¥ng tin showtime ƒë·ªÉ c√≥ date
            # ========================================
            # C·∫ßn date ƒë·ªÉ l·∫•y gi√° v√© t·ª´ /ticket-prices/getprice/:cinemaId/:date
            showtime_date = None
            
            # Th·ª≠ l·∫•y t·ª´ available_seats (c√≥ th·ªÉ c√≥ start_time)
            if available_seats and len(available_seats) > 0:
                # Seats c√≥ th·ªÉ c√≥ th√¥ng tin showtime
                pass
            
            # Ho·∫∑c query l·∫°i t·ª´ API showtimes
            try:
                showtime_detail_response = requests.get(
                    f"{API_BASE_URL}/showtimes/all",
                    timeout=5
                )
                
                if showtime_detail_response.status_code == 200:
                    all_st = showtime_detail_response.json()
                    st_list = []
                    
                    if isinstance(all_st, dict):
                        st_list = all_st.get('showtimes', []) or all_st.get('data', [])
                    elif isinstance(all_st, list):
                        st_list = all_st
                    
                    # T√¨m showtime
                    st_info = next((s for s in st_list if str(s.get('id')) == str(showtime_id)), None)
                    
                    if st_info:
                        start_time = st_info.get('start_time') or st_info.get('show_time')
                        if start_time:
                            try:
                                # Parse ISO date: "2025-10-11T23:10:00.000Z"
                                dt = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
                                showtime_date = dt.strftime('%Y-%m-%d')
                                logger.info(f"Extracted showtime date: {showtime_date}")
                            except:
                                pass
            except Exception as e:
                logger.warning(f"Could not get showtime date: {e}")
            
            # Fallback to today if can't find date
            if not showtime_date:
                showtime_date = datetime.now().strftime('%Y-%m-%d')
                logger.info(f"Using today as fallback date: {showtime_date}")
            
            # ========================================
            # B∆Ø·ªöC 3: L·∫•y gi√° v√© t·ª´ ticket-prices API
            # ========================================
            ticket_prices_map = {}
            
            try:
                price_response = requests.get(
                    f"{API_BASE_URL}/ticket-prices/getprice/{cinema_id}/{showtime_date}",
                    timeout=5
                )
                
                logger.info(f"Ticket prices API status: {price_response.status_code}")
                
                if price_response.status_code == 200:
                    price_data = price_response.json()
                    logger.info(f"Price data: {price_data}")
                    
                    # Parse response (c√≥ th·ªÉ l√† list ho·∫∑c dict)
                    prices = []
                    if isinstance(price_data, dict):
                        prices = price_data.get('prices', []) or price_data.get('data', [])
                    elif isinstance(price_data, list):
                        prices = price_data
                    
                    # Map seat_type ‚Üí price
                    for price_item in prices:
                        seat_type = (
                            price_item.get('seat_type') or 
                            price_item.get('seat_type_name') or
                            price_item.get('type')
                        )
                        base_price = price_item.get('base_price') or price_item.get('price')
                        
                        if seat_type and base_price:
                            ticket_prices_map[seat_type.lower()] = float(base_price)
                    
                    logger.info(f"Ticket prices map: {ticket_prices_map}")
                else:
                    logger.warning(f"Could not get ticket prices: HTTP {price_response.status_code}")
            except Exception as e:
                logger.error(f"Error getting ticket prices: {e}")
            
            # N·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c gi√°, d√πng gi√° m·∫∑c ƒë·ªãnh
            if not ticket_prices_map:
                ticket_prices_map = {
                    'standard': 50000,
                    'normal': 50000,
                    'vip': 80000,
                    'couple': 150000,
                    'sweetbox': 150000
                }
                logger.warning(f"Using default prices: {ticket_prices_map}")
            
            # ========================================
            # B∆Ø·ªöC 4: Chu·∫©n b·ªã tickets array v·ªõi ƒë√∫ng format
            # ========================================
            tickets = []
            for seat_number in seat_numbers:
                # T√¨m seat trong available_seats
                seat_info = next((s for s in available_seats if s.get('seat_number') == seat_number), None)
                
                if not seat_info:
                    dispatcher.utter_message(
                        text=f"‚ùå Gh·∫ø **{seat_number}** kh√¥ng kh·∫£ d·ª•ng ho·∫∑c ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t!"
                    )
                    return []
                
                # L·∫•y seat_type t·ª´ seat_info
                seat_type = (
                    seat_info.get('seat_type') or 
                    seat_info.get('type') or 
                    seat_info.get('seat_type_name') or
                    'standard'
                ).lower()
                
                logger.info(f"Seat {seat_number}: type = {seat_type}")
                
                # L·∫•y ticket_price t·ª´ map theo seat_type
                ticket_price = ticket_prices_map.get(seat_type)
                
                # Fallback n·∫øu kh√¥ng t√¨m th·∫•y
                if not ticket_price:
                    ticket_price = ticket_prices_map.get('standard', 50000)
                    logger.warning(f"Price not found for type {seat_type}, using default: {ticket_price}")
                
                # Ensure ticket_price is number
                ticket_price = float(ticket_price)
                
                # Backend expects seat_id to be seat_number (A1, A2, etc)
                tickets.append({
                    "seat_id": seat_number,  # seat_number nh∆∞ A1, A2
                    "ticket_price": ticket_price  # Ph·∫£i l√† number
                })
            
            logger.info(f"Prepared tickets: {tickets}")
            
            # Validate tickets tr∆∞·ªõc khi g·ª≠i
            for ticket in tickets:
                if not ticket.get('seat_id'):
                    dispatcher.utter_message(text="‚ùå L·ªói: seat_id b·ªã thi·∫øu")
                    return []
                if not ticket.get('ticket_price') or not isinstance(ticket['ticket_price'], (int, float)):
                    dispatcher.utter_message(
                        text=f"‚ùå L·ªói: Kh√¥ng l·∫•y ƒë∆∞·ª£c gi√° v√© cho gh·∫ø {ticket.get('seat_id')}\n"
                             f"ticket_price = {ticket.get('ticket_price')} (type: {type(ticket.get('ticket_price'))})"
                    )
                    return []
            
            # ========================================
            # B∆Ø·ªöC 3: Chu·∫©n b·ªã d·ªØ li·ªáu booking v·ªõi ƒë·∫ßy ƒë·ªß tr∆∞·ªùng
            # ========================================
            booking_data = {
                "cinema_id": cinema_id,
                "user_id": user_id,
                "showtime_id": int(showtime_id),
                "tickets": tickets,
                "services": [],
                "payment_method": "qr code",  # M·∫∑c ƒë·ªãnh QR code
                "status": "pending"  # M·∫∑c ƒë·ªãnh pending
            }
            
            logger.info(f"Creating booking: {booking_data}")
            
            # ========================================
            # B∆Ø·ªöC 5: G·ªçi API t·∫°o booking
            # ========================================
            response = requests.post(
                f"{API_BASE_URL}/bookings/create-booking",
                json=booking_data,
                timeout=10
            )
            
            logger.info(f"Booking response status: {response.status_code}")
            
            if response.status_code == 201 or response.status_code == 200:
                result = response.json()
                
                if not result.get('success'):
                    error_msg = result.get('message', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')
                    dispatcher.utter_message(
                        text=f"‚ùå **ƒê·∫∑t v√© th·∫•t b·∫°i!**\n\nL√Ω do: {error_msg}"
                    )
                    return []
                
                data = result.get('data', {})
                order_id = data.get('order_id')
                
                if order_id:
                    seats_display = ', '.join(seat_numbers) if isinstance(seat_numbers, list) else seat_numbers
                    grand_total = data.get('grand_total', 0)
                    
                    message = "‚úÖ **ƒê·∫∂T V√â TH√ÄNH C√îNG!**\n\n"
                    message += f"üìã **M√£ ƒë∆°n h√†ng:** {order_id}\n"
                    message += f"üé¨ **Su·∫•t chi·∫øu:** ID {showtime_id}\n"
                    message += f"ü™ë **Gh·∫ø ƒë√£ ƒë·∫∑t:** {seats_display}\n"
                    message += f"üí∞ **T·ªïng ti·ªÅn:** {grand_total:,} VND\n\n"
                    message += "‚è∞ Vui l√≤ng **thanh to√°n trong 15 ph√∫t** ƒë·ªÉ gi·ªØ v√©!\n\n"
                    message += "üí≥ B·∫°n c√≥ th·ªÉ h·ªèi: 'Thanh to√°n nh∆∞ th·∫ø n√†o?' ƒë·ªÉ ƒë∆∞·ª£c h∆∞·ªõng d·∫´n."
                    
                    dispatcher.utter_message(text=message)
                    return [
                        SlotSet("order_id", order_id),
                        SlotSet("grand_total", float(grand_total)),  # Add this line
                        SlotSet("showtime_id", None),
                        SlotSet("seat_numbers", None)
                    ]
                else:
                    dispatcher.utter_message(
                        text="‚úÖ ƒê·∫∑t v√© th√†nh c√¥ng nh∆∞ng kh√¥ng nh·∫≠n ƒë∆∞·ª£c m√£ ƒë∆°n h√†ng."
                    )
            else:
                try:
                    error_data = response.json()
                    error_msg = error_data.get('message', '') or error_data.get('error', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')
                except:
                    error_msg = f"HTTP {response.status_code}"
                
                logger.error(f"Booking failed: {error_msg}")
                logger.error(f"Response body: {response.text}")
                
                dispatcher.utter_message(
                    text=f"‚ùå **ƒê·∫∑t v√© th·∫•t b·∫°i!**\n\n"
                         f"L√Ω do: {error_msg}\n\n"
                         f"C√≥ th·ªÉ:\n"
                         f"‚Ä¢ Gh·∫ø ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t\n"
                         f"‚Ä¢ Su·∫•t chi·∫øu kh√¥ng c√≤n kh·∫£ d·ª•ng\n"
                         f"‚Ä¢ M√£ gh·∫ø kh√¥ng ƒë√∫ng"
                )
                
        except requests.exceptions.Timeout:
            dispatcher.utter_message(text="‚è±Ô∏è Timeout khi ƒë·∫∑t v√©. Vui l√≤ng th·ª≠ l·∫°i.")
        except requests.exceptions.RequestException as e:
            logger.error(f"Request error in booking: {str(e)}")
            dispatcher.utter_message(text="‚ùå L·ªói k·∫øt n·ªëi API khi ƒë·∫∑t v√©.")
        except Exception as e:
            logger.error(f"Error in booking: {str(e)}", exc_info=True)
            dispatcher.utter_message(
                text=f"‚ùå C√≥ l·ªói x·∫£y ra khi ƒë·∫∑t v√©: {str(e)}"
            )
        
        return []
    
    def extract_seat_numbers(self, text):
        """Extract seat numbers t·ª´ text"""
        import re
        
        # T√¨m pattern: gh·∫ø A1 A2, gh·∫ø A1, A2, etc
        # Pattern matches: A1, B2, C10, V1, I4, etc
        seat_pattern = r'\b([A-Z]\d+)\b'
        seats = re.findall(seat_pattern, text.upper())
        
        logger.info(f"Extracted seats from '{text}': {seats}")
        return seats if seats else []
    
    def find_cinema_id_from_name(self, cinema_name):
        """T√¨m cinema_id t·ª´ t√™n r·∫°p"""
        try:
            response = requests.get(f"{API_BASE_URL}/cinemas", timeout=5)
            
            if response.status_code != 200:
                return None
            
            cinemas_data = response.json()
            
            if isinstance(cinemas_data, dict):
                cinemas = cinemas_data.get('cinemas', []) or cinemas_data.get('data', [])
            elif isinstance(cinemas_data, list):
                cinemas = cinemas_data
            else:
                return None
            
            cinema_name_lower = cinema_name.lower()
            
            for cinema in cinemas:
                if not isinstance(cinema, dict):
                    continue
                
                name = str(cinema.get('cinema_name', '') or cinema.get('name', '')).lower()
                
                if cinema_name_lower in name or name in cinema_name_lower:
                    return cinema.get('id') or cinema.get('cinema_id')
            
            return None
            
        except Exception as e:
            logger.error(f"Error finding cinema: {str(e)}")
            return None

class ActionRedirectToPayment(Action):
    def name(self) -> Text:
        return "action_redirect_to_payment"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        order_id = tracker.get_slot("order_id")
        grand_total = tracker.get_slot("grand_total")
        
        if not order_id or not grand_total:
            dispatcher.utter_message(
                text="‚ùå Thi·∫øu th√¥ng tin ƒë∆°n h√†ng.\n"
                     "B·∫°n c√≥ th·ªÉ ƒë·∫∑t v√© m·ªõi b·∫±ng c√°ch n√≥i: 'ƒê·∫∑t v√© phim [t√™n phim]'"
            )
            return []
        
        # T·∫°o URL thanh to√°n c·ªë ƒë·ªãnh
        payment_url = "http://localhost:5173/qr-payment"
        
        message = "üí≥ **H∆Ø·ªöNG D·∫™N THANH TO√ÅN**\n\n"
        message += f"üîó Vui l√≤ng truy c·∫≠p link sau ƒë·ªÉ thanh to√°n:\n"
        message += f"<a href='{payment_url}' target='_blank'>Link thanh to√°n</a>\n\n"
        message += f"üìå **Th√¥ng tin thanh to√°n:**\n"
        message += f"‚Ä¢ M√£ ƒë∆°n h√†ng: {order_id}\n"
        message += f"‚Ä¢ T·ªïng ti·ªÅn: {grand_total:,} VND\n"
        message += "‚Ä¢ Ph∆∞∆°ng th·ª©c: QR Code (VNPay, Momo, ZaloPay) ho·∫∑c chuy·ªÉn kho·∫£n ng√¢n h√†ng\n\n"
        message += "‚è∞ Th·ªùi gian gi·ªØ v√©: **15 ph√∫t**"
        
        dispatcher.utter_message(
            text=message,
            custom={
                "bookingData": {
                    "order_id": order_id,
                    "grand_total": float(grand_total),
                    "payment_url": payment_url
                }
            }
        )
        
        return []

class ActionGetCinemaInfo(Action):
    def name(self) -> Text:
        return "action_get_cinema_info"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        cinema_name = tracker.get_slot("cinema_name")
        
        try:
            response = requests.get(f"{API_BASE_URL}/cinemas", timeout=5)
            
            if response.status_code == 200:
                cinemas_data = response.json()
                
                if isinstance(cinemas_data, dict):
                    cinemas = cinemas_data.get('cinemas', []) or cinemas_data.get('data', [])
                elif isinstance(cinemas_data, list):
                    cinemas = cinemas_data
                else:
                    dispatcher.utter_message(text="ƒê·ªãnh d·∫°ng d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.")
                    return []
                
                cinemas = [c for c in cinemas if isinstance(c, dict)]
                
                if cinema_name:
                    cinema_name_lower = cinema_name.lower()
                    cinemas = [
                        c for c in cinemas
                        if cinema_name_lower in str(c.get('cinema_name', '') or c.get('name', '')).lower()
                    ]
                
                if cinemas:
                    message = "üé¨ **TH√îNG TIN R·∫†P CHI·∫æU PHIM**\n\n"
                    
                    for cinema in cinemas[:5]:
                        name = cinema.get('cinema_name', '') or cinema.get('name', 'N/A')
                        address = cinema.get('address', 'N/A')
                        phone = cinema.get('cinema_phone', '') or cinema.get('phone', 'N/A')
                        cinema_id = cinema.get('id') or cinema.get('cinema_id', 'N/A')
                        
                        message += f"üè¢ **{name}**\n"
                        message += f"üìç ƒê·ªãa ch·ªâ: {address}\n"
                        message += f"‚òéÔ∏è Hotline: {phone}\n"
                        message += f"üÜî ID: {cinema_id}\n\n"
                    
                    message += "üí° B·∫°n c√≥ th·ªÉ h·ªèi: 'L·ªãch chi·∫øu t·∫°i [t√™n r·∫°p]' ƒë·ªÉ xem l·ªãch chi·∫øu!"
                    
                    dispatcher.utter_message(text=message)
                else:
                    dispatcher.utter_message(
                        text="‚ùå Kh√¥ng t√¨m th·∫•y r·∫°p ph√π h·ª£p.\n"
                             "Vui l√≤ng th·ª≠ l·∫°i v·ªõi t√™n r·∫°p kh√°c."
                    )
            else:
                dispatcher.utter_message(text="Kh√¥ng th·ªÉ l·∫•y th√¥ng tin r·∫°p.")
                
        except Exception as e:
            logger.error(f"Error in cinema info: {str(e)}")
            dispatcher.utter_message(text="C√≥ l·ªói x·∫£y ra.")
        
        return []


class ActionGetMovieInfo(Action):
    def name(self) -> Text:
        return "action_get_movie_info"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        movie_name = tracker.get_slot("movie_name")
        
        try:
            response = requests.get(f"{API_BASE_URL}/movies", timeout=5)
            
            if response.status_code == 200:
                movies_data = response.json()
                
                if isinstance(movies_data, dict):
                    movies = movies_data.get('data', []) or movies_data.get('movies', [])
                elif isinstance(movies_data, list):
                    movies = movies_data
                else:
                    dispatcher.utter_message(text="ƒê·ªãnh d·∫°ng d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.")
                    return []
                
                movies = [m for m in movies if isinstance(m, dict)]
                
                if movie_name:
                    movie_name_lower = movie_name.lower()
                    movies = [
                        m for m in movies
                        if movie_name_lower in str(m.get('title', '') or m.get('movie_name', '')).lower()
                    ]
                
                if movies:
                    message = "üé¨ **TH√îNG TIN PHIM**\n\n"
                    
                    for movie in movies[:3]:
                        title = movie.get('title', '') or movie.get('movie_name', 'N/A')
                        release = movie.get('release_date', 'N/A')
                        duration = movie.get('duration', '') or movie.get('runtime', 'N/A')
                        genre = movie.get('genre', '') or movie.get('genres', [])
                        if isinstance(genre, list):
                            genre = ', '.join(genre)
                        desc = str(movie.get('description', '') or movie.get('overview', ''))
                        vote_avg = movie.get('vote_average', '')
                        movie_id = movie.get('movie_id', '') or movie.get('id', '')
                        
                        message += f"üé¨ **{title}**\n"
                        
                        if release != 'N/A':
                            try:
                                release_date = datetime.fromisoformat(release.replace('Z', '+00:00'))
                                release = release_date.strftime('%d/%m/%Y')
                            except:
                                pass
                            message += f"üìÖ Kh·ªüi chi·∫øu: {release}\n"
                        
                        if duration != 'N/A':
                            message += f"‚è±Ô∏è Th·ªùi l∆∞·ª£ng: {duration} ph√∫t\n"
                        
                        if genre:
                            message += f"üé≠ Th·ªÉ lo·∫°i: {genre}\n"
                        
                        if vote_avg:
                            message += f"‚≠ê ƒê√°nh gi√°: {vote_avg}/10\n"
                        
                        if movie_id:
                            message += f"üÜî ID: {movie_id}\n"
                        
                        if desc and len(desc) > 10:
                            desc_short = desc[:200] + "..." if len(desc) > 200 else desc
                            message += f"üìù M√¥ t·∫£: {desc_short}\n"
                        
                        message += "\n"
                    
                    message += "üí° B·∫°n c√≥ th·ªÉ h·ªèi: 'L·ªãch chi·∫øu phim [t√™n phim]' ƒë·ªÉ xem su·∫•t chi·∫øu!"
                    
                    dispatcher.utter_message(text=message)
                else:
                    dispatcher.utter_message(
                        text="‚ùå Kh√¥ng t√¨m th·∫•y phim ph√π h·ª£p.\n"
                             "Vui l√≤ng th·ª≠ l·∫°i v·ªõi t√™n phim kh√°c."
                    )
            else:
                dispatcher.utter_message(text="Kh√¥ng th·ªÉ l·∫•y th√¥ng tin phim.")
                
        except Exception as e:
            logger.error(f"Error in movie info: {str(e)}")
            dispatcher.utter_message(text="C√≥ l·ªói x·∫£y ra.")
        
        return []